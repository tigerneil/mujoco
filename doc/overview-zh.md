# 概述

## [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#introduction)介绍

**MuJoCo**代表**穆**lti-**乔**与诠释动力**有限公司**ntact。它是一种通用物理引擎，旨在促进机器人、生物力学、图形和动画、机器学习以及其他需要快速准确地模拟与环境交互的关节结构的领域的研究和开发。它最初由 Roboti LLC 开发，于 2021 年 10 月被 DeepMind收购并[免费提供](https://github.com/deepmind/mujoco/blob/main/LICENSE)，目标是使 MuJoCo 成为一个开源项目。MuJoCo 代码库将在 GitHub 上的[deepmind/mujoco](https://github.com/deepmind/mujoco)存储库中提供。

MuJoCo 是一个带有 C API 的 C/C++ 库，供研究人员和开发人员使用。运行时模拟模块经过调整以最大限度地提高性能，并在由内置 XML 解析器和编译器预先分配的低级数据结构上运行。用户使用原生 MJCF 场景描述语言定义模型——一种 XML 文件格式，旨在尽可能让人类可读和可编辑。也可以加载 URDF 模型文件。该库包括具有原生 GUI 的交互式可视化，在 OpenGL 中呈现。MuJoCo 进一步公开了大量用于计算物理相关量的效用函数。

MuJoCo 可用于实现基于模型的计算，例如控制综合、状态估计、系统识别、机制设计、通过逆动力学的数据分析以及机器学习应用程序的并行采样。它还可以用作更传统的模拟器，包括用于游戏和交互式虚拟环境。

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#key-features)主要特点

MuJoCo 有很多功能。在这里，我们概述了最值得注意的那些。

广义坐标结合现代接触动力学

物理引擎传统上分为两类。机器人和生物力学引擎在广义或关节坐标中使用高效且准确的递归算法。然而，他们要么忽略了接触动力学，要么依赖于早期的弹簧阻尼方法，这种方法需要非常小的时间步长。游戏引擎使用更现代的方法，通过解决优化问题来找到接触力。然而，他们经常求助于过度指定的笛卡尔表示，其中在数值上强加联合约束，当涉及精细的运动结构时会导致不准确和不稳定性。MuJoCo 是第一个结合了两全其美的通用引擎：广义坐标中的模拟和基于优化的接触动力学。其他模拟器最近已适应使用 MuJoCo 的方法，但这通常与它们的所有功能不兼容，因为它们从一开始就没有设计成这样做。习惯了游戏引擎的用户一开始可能会觉得广义坐标有悖常理；看[:ref:`澄清`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id1)部分如下。

软、凸和解析可逆的接触动力学

在现代接触动力学方法中，摩擦接触引起的力或冲量通常被定义为线性或非线性互补问题（LCP 或 NCP）的解决方案，两者都是 NP-hard。MuJoCo 基于接触物理的不同公式，该公式简化为凸优化问题，详细解释请参见[:doc:`computation`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id3)章节。我们的模型允许软接触和其他约束，并具有独特定义的逆促进数据分析和控制应用程序。有多种优化算法可供选择，包括对可处理椭圆摩擦锥的投影 Gauss-Siedel 方法的推广。求解器提供了摩擦接触的统一处理，包括扭转和滚动摩擦、无摩擦接触、关节和肌腱限制、关节和肌腱中的干摩擦，以及各种等式约束。

肌腱几何

MuJoCo 可以对肌腱的 3D 几何形状进行建模 - 肌腱是服从包裹和过孔点约束的最小路径长度字符串。该机制类似于 OpenSim 中的机制，但实现了一组更受限制的封闭形式的包装选项以加速计算。它还提供机器人特定的结构，例如滑轮和耦合自由度。肌腱可用于驱动以及对肌腱长度施加不等式或等式约束。

通用驱动模型

在使用与模型无关的 API 的同时设计足够丰富的驱动模型具有挑战性。MuJoCo 通过采用抽象驱动模型来实现这一目标，该模型可以具有不同类型的传输、力生成和内部动力学（即使整体动力学成为三阶的状态变量）。这些组件可以实例化，以便以统一的方式对电机、气动和液压缸、PD 控制器、生物肌肉和许多其他执行器进行建模。

可重构计算流水线

MuJoCo 有一个顶级步进函数[：ref:`mj_step`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id5)，它运行整个前向动力学并推进模拟的状态。然而，在模拟之外的许多应用中，能够运行计算管道的选定部分是有益的。为此，MuJoCo 提供了大量的[:ref:`flags <option-flag>`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id7)可以任意组合设置，允许用户根据需要重新配置管道，超越通过[:ref](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id9)选择算法和算法参数[： `选项 <选项>`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id9)。此外，可以直接调用许多低级函数。用户定义的回调可以实现自定义力场、执行器、碰撞例程和反馈控制器。

模型编译

如上所述，用户定义了一个名为 MJCF 的 XML 文件格式的 MuJoCo 模型。这个模型然后由内置编译器编译成低级数据结构[:ref:`mjModel`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id11)，它被交叉索引并针对运行时计算进行了优化。编译后的模型也可以保存在二进制 MJB 文件中。

模型与数据分离

MuJoCo 在运行时将仿真参数分成两个数据结构（C 结构）：

-   `mjModel`包含模型描述，预计将保持不变。其中嵌入了其他包含模拟和可视化选项的结构，这些选项需要偶尔更改，但这是由用户完成的。
-   `mjData`包含所有动态变量和中间结果。它用作暂存器，所有函数在其中读取其输入并写入其输出 - 然后成为模拟管道中后续阶段的输入。它还包含一个预先分配和内部管理的堆栈，以便运行时模块在模型初始化后不需要调用内存分配函数。

`mjModel`由编译器构建。[:ref:`mjData`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id13)是在运行时构造的，给定 `mjModel`. 这种分离使得模拟多个模型以及每个模型的多个状态和控件变得容易，进而促进[:ref:`multi-threading <siMultithread>`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id15)用于采样和[:ref:`有限差异 <saDerivative>`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id17)。顶级 API 函数反映了这种基本分离，并具有以下格式：

void  mj_step ( const mjModel* m, mjData* d);

交互式模拟和可视化

原生[:ref:`3D 可视化器 <Visualization>`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id19)提供网格和几何图元、纹理、反射、阴影、雾、透明度、线框、天空盒、立体可视化（在支持四缓冲 OpenGL 的视频卡上）的渲染。此功能用于生成 3D 渲染，帮助用户深入了解物理模拟，包括视觉辅助工具，例如自动生成的模型骨架、等效惯性框、接触位置和法线、可分为法向分量和切向分量的接触力、外部扰动力、局部框架、关节和执行器轴以及文本标签。可视化器需要一个带有 OpenGL 渲染上下文的通用窗口，从而允许用户采用他们选择的 GUI 库。代码示例 [:ref:`simulate.cc <saSimulate>`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id21)与 MuJoCo 一起发布，展示了如何使用 GLFW 库来做到这一点。一个相关的可用性功能是能够“进入”模拟、推动对象并查看物理响应。用户选择要施加外力和扭矩的物体，并查看扰动的实时渲染及其动态结果。这可用于直观地调试模型、测试反馈控制器的响应或将模型配置为所需的姿势。

强大而直观的建模语言

MuJoCo 有自己的建模语言，称为 MJCF。MJCF 的目标是提供对 MuJoCo 的所有计算能力的访问，同时使用户能够快速开发新模型并对其进行试验。这个目标在很大程度上是由于广泛的[:ref:`默认设置 <CDefault>`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id23)机制实现的，它类似于 HTML 中的级联样式表 (CSS)。虽然 MJCF 有许多元素和属性，但用户需要在任何给定模型中设置的元素和属性少得惊人。这使得 MJCF 文件比许多其他格式更短、更易读。

复合柔性对象的自动生成

MuJoCo 的软约束可用于对绳索、布料和可变形 3D 对象进行建模。这需要大量的规则体、关节、肌腱和约束来协同工作。建模语言具有高级宏，模型编译器会自动将其扩展为标准模型元素的必要集合。重要的是，这些生成的灵活对象能够与模拟的其余部分完全交互。

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#model-instances)模型实例

MuJoCo 中有几个实体称为“模型”。用户在用 MJCF 或 URDF 编写的 XML 文件中定义模型。然后，该软件可以在不同的媒体（文件或内存）和不同的描述级别（高或低）中创建同一模型的多个实例。所有组合都是可能的，如下表所示：

 

高水平

低级

**文件**

MJCF/URDF (XML)

MJB（二进制）

**记忆**

mjCModel（C++ 类）

mjModel（C 结构体）

执行所有运行时计算`mjModel`，手动创建太复杂。这就是为什么我们有两个级别的建模。存在高层是为了方便用户：它的唯一目的是编译成可以执行计算的低层模型。结果`mjModel`可以加载并保存到二进制文件 (MJB) 中，但是这些是特定于版本的并且无法反编译，因此模型应始终作为 XML 文件进行维护。

（内部）C++ 类`mjCModel`与 MJCF 文件格式大致一一对应。XML 解析器解释 MJCF 或 URDF 文件并创建相应的`mjCModel`. 原则上用户可以通过`mjCModel`编程方式创建 ，然后将其保存到 MJCF 或编译它。但是，此功能尚未公开，因为无法从独立于编译器的库中导出 C++ API。有一个计划围绕它开发一个 C 包装器，但目前解析器和编译器总是一起调用，并且模型只能在 XML 中创建。

下图显示了获得一个的不同路径`mjModel`（同样，第二个要点尚不可用）：

-   (文本编辑器) → MJCF/URDF 文件 → (MuJoCo 解析器 → mjCModel → MuJoCo 编译器) → mjModel
-   (用户代码) → mjCModel → (MuJoCo 编译器) → mjModel
-   MJB文件→（MuJoCo加载器）→mjModel

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#examples)例子

这是 MuJoCo 的 MJCF 格式的简单模型。它定义了一个固定到世界的平面、一个更好地照亮对象和投射阴影的灯光，以及一个具有 6 个自由度的浮动框（这就是“自由”关节所做的）。

[你好.xml](https://github.com/tigerneil/mujoco-zh/blob/main/doc/_static/hello.xml) :

<穆乔科> <世界体> <光 漫射= " .5 .5 .5 "  pos = " 0 0 3 "  dir = " 0 0 -1 " /> < geom  type = " plane "  size = " 1 1 0.1 "  rgba = " .9 0 0 1 " /> <体 POS = “ 0 0 1 ” > <联合 类型= “自由” /> < geom  type = " box "  size = " .1 .2 .3 "  rgba = " 0 .9 0 1 " /> </正文> </世界体> </穆乔科>

内置的 OpenGL 可视化器将此模型渲染为：

[![图像/概述/hello.png](https://github.com/tigerneil/mujoco-zh/raw/main/doc/images/overview/hello.png)](https://github.com/tigerneil/mujoco-zh/blob/main/doc/images/overview/hello.png)

如果模拟这个模型，盒子会掉在地上。下面给出了没有渲染的被动动力学的基本模拟代码。

[你好.c](https://github.com/tigerneil/mujoco-zh/blob/main/doc/_static/hello.c)：

#包含 “ mujoco.h ” #包含 “ stdio.h ”
字符错误[ 1000 ]； mjModel* m; mjData* d;
int  main ( void ) {
   //从文件加载模型并检查错误 m = mj_loadXML ( " hello.xml " , NULL , error, 1000 ); 如果（！米） {
      printf ( " %s \n "，错误); 返回 1 ; }
   //制作模型对应的数据 d = mj_makeData (m);
   //运行模拟 10 秒，
   同时(d-> time < 10 ) mj_step (m, d);
   //释放模型和数据
   mj_deleteData (d); mj_deleteModel (m);
   返回 0 ; }

这在技术上是一个 C 文件，但它也是一个合法的 C++ 文件。事实上，MuJoCo API 与 C 和 C++ 兼容。通常用户代码会用 C++ 编写，因为它增加了便利性，并且不会因为计算瓶颈在已经高度优化的模拟器中而牺牲效率。

函数[:ref:`mj_step`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id26)是顶级函数，它将模拟状态提前一个时间步长。这个例子当然只是一个被动动力系统。当用户指定控制或施加力量并开始与系统交互时，事情会变得更有趣。

接下来我们提供一个更详细的例子来说明 MJCF 的几个特性。

[示例.xml](https://github.com/tigerneil/mujoco-zh/blob/main/doc/_static/example.xml)：

< mujoco 模型= "示例" > <编译器 坐标= "全局" /> <默认> < geom  rgba = " .8 .6 .4 1 " /> </默认> <资产> <纹理 类型= “天空盒” 内置= “渐变”  rgb1 = “ 1 1 1 ”  rgb2 = “. 6 .8 1 ”
                 宽度= “ 256 ” 高度= “ 256 ” /> </资产> <世界体> < light  pos = " 0 1 1 "  dir = " 0 -1 -1 " 漫反射= " 1 1 1 " /> <身体> < geom  type = " capsule "  fromto = " 0 0 1 0 0 0.6 "  size = " 0.06 " /> <关节 类型= “球”  pos = “ 0 0 1 ” /> <身体> < geom  type = " capsule "  fromto = " 0 0 0.6 0.3 0 0.6 "  size = " 0.04 " /> <关节 类型= “铰链”  pos = “ 0 0 0.6 ” 轴= “ 0 1 0 ” /> <关节 类型= “铰链”  pos = “ 0 0 0.6 ” 轴= “ 1 0 0 ” /> <身体> < geom  type = "椭圆体"  pos = " 0.4 0 0.6 "  size = " 0.1 0.08 0.02 " /> <站点 名称= “ end1 ”  pos = “ 0.5 0 0.6 ” 类型= “球体” 大小= “ 0.01 ” /> <关节 类型= “铰链”  pos = “ 0.3 0 0.6 ” 轴= “ 0 1 0 ” /> <关节 类型= “铰链”  pos = “ 0.3 0 0.6 ” 轴= “ 0 0 1 ” /> </正文> </正文> </正文> <身体> < geom  type = "圆柱"  fromto = " 0.5 0 0.2 0.5 0 0 "  size = " 0.07 " /> <站点 名称= “ end2 ”  pos = “ 0.5 0 0.2 ” 类型= “球体” 大小= “ 0.01 ” /> <联合 类型= “自由” /> </正文> </世界体> <肌腱> <空间 限制= “真” 范围= “ 0 0.6 ” 宽度= “ 0.005 ” > <站点 站点= “ end1 ” /> <站点 站点= “ end2 ” /> </空间> </筋> </穆乔科>

这个模型是一个 7 自由度的臂，“固定”一根绳子，另一端连接一个圆柱体。字符串被实现为具有长度限制的肌腱。肩部有球关节，肘部和腕部有成对的铰链关节。圆柱体内的方框表示一个自由的“关节”。XML 中的外部 body 元素是必需的 [:el:`worldbody`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id28)。请注意，在两个实体之间使用多个关节不需要创建虚拟实体。

MJCF 文件包含指定模型所需的最少信息。胶囊由空间中的线段定义——在这种情况下，只需要胶囊的半径。身体框架的位置和方向是从属于它们的几何体推断出来的。惯性属性是在均匀密度假设下从几何形状推断出来的。命名这两个站点是因为肌腱定义需要引用它们，但没有其他名称。关节轴仅针对铰链关节而不是球关节定义。碰撞规则是自动定义的。摩擦属性、重力、模拟时间步长等设置为默认值。顶部指定的默认几何颜色适用于所有几何。

除了将编译后的模型保存为二进制 MJB 格式之外，我们还可以将其保存为 MJCF 或人类可读的文本； 分别参见 [example_saved.xml](https://github.com/tigerneil/mujoco-zh/blob/main/doc/_static/example_saved.xml)和[example_saved.txt](https://github.com/tigerneil/mujoco-zh/blob/main/doc/_static/example_saved.txt)。XML 版本与原始版本类似，而文本版本包含来自 `mjModel`. 将文本版本与 XML 版本进行比较揭示了模型编译器为我们做了多少工作。

## [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#model-elements)模型元素

本节简要说明可以包含在 MuJoCo 模型中的所有元素。稍后我们将更详细地解释底层计算、在 MJCF 中指定元素的方式以及它们在 `mjModel`.

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#options)选项

每个型号都有下面列出的三组选项。他们总是包括在内。如果 XML 文件中未指定它们的值，则使用默认值。这些选项的设计使得用户可以在每个模拟时间步长之前更改它们的值。但是，在一个时间步长内，不应更改任何选项。

`mjOption`

该结构包含影响物理模拟的所有选项。它用于选择算法并设置它们的参数，启用和禁用模拟管道的不同部分，以及调整系统级物理属性，例如重力。

`mjVisual`

此结构包含所有可视化选项。还有其他 OpenGL 渲染选项，但这些选项依赖于会话，而不是模型的一部分。

`mjStatistic`

此结构包含有关由编译器计算的模型的统计信息：平均体重、模型的空间范围等。包含它是为了提供信息，也因为可视化器将其用于自动缩放。

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#assets)资产

资产本身并不是模型元素。模型元素可以引用它们，在这种情况下，资产会以某种方式改变引用元素的属性。一个资产可以被多个模型元素引用。由于包含资产的唯一目的是引用它，而引用只能通过名称来完成，因此每个资产都有一个名称（可以从文件名中推断出适用的名称）。相反，常规元素的名称可以保持未定义。

网

MuJoCo 可以从二进制 STL 文件加载三角网格。[MeshLab](https://www.meshlab.net/)等软件[](https://www.meshlab.net/) 可用于从其他格式转换。虽然可以加载任何三角形集合并将其可视化为网格，但碰撞检测器与凸包一起工作。有用于缩放网格以及为其拟合原始几何形状的编译时选项。网格还可用于自动推断惯性属性 - 通过将其视为三棱锥的并集并将它们的质量和惯性结合起来。注意 STL 格式不支持颜色；一些软件包在未使用的字段中写入颜色信息，但这并不一致。相反，使用参考几何体的材料属性对网格进行着色。相反，所有空间属性都由网格数据决定。MuJoCo 支持自定义二进制文件格式，可以额外指定法线和纹理坐标。

皮肤

蒙皮网格（或皮肤）是其形状可以在运行时变形的网格。它们的顶点附加到刚体（在此上下文中称为骨骼）并且每个顶点可以属于多个骨骼，从而导致蒙皮的平滑变形。皮肤是纯粹的可视化对象，不会影响物理效果，但是它们可以显着增强视觉真实感。皮肤可以从自定义二进制文件加载，或直接嵌入在 XML 中，类似于网格。自动生成复合柔性对象时，模型编译器还会为这些对象生成皮肤。

高度场

高度字段可以从 PNG 文件（在内部转换为灰度）或从稍后描述的自定义二进制格式的文件中加载。高度字段是高程数据的矩形网格。编译器将数据标准化到范围 [0-1]。高度场的实际空间范围然后由参考几何体的尺寸参数确定。高度场只能从附加到世界体的几何体中引用。出于渲染和碰撞检测的目的，网格矩形会自动进行三角剖分，因此高度场被视为三棱柱的并集。与这种复合对象的碰撞检测原则上可以为单个几何对生成大量接触点。如果发生这种情况，则仅保留前 64 个接触点。

质地

纹理可以从 PNG 文件加载或由编译器根据用户定义的程序参数合成。还可以选择在模型创建时将纹理留空，然后在运行时更改它——以便在 MuJoCo 模拟中渲染视频，或创建其他动态效果。可视化器支持两种类型的纹理映射：2D 和立方体。2D 映射对于平面和高度场很有用。立方体贴图对于围绕 3D 对象的“收缩包裹”纹理非常有用，而无需指定纹理坐标。它还用于创建天空盒。立方体贴图的六个面可以从单独的图像文件或一个合成图像文件加载，或者通过重复相同的图像生成。与直接从模型元素引用的所有其他资产不同，

材料

材料用于控制几何体、位置和肌腱的外观。这是通过引用来自相应模型元素的材料来完成的。外观包括纹理贴图以及与以下 OpenGL 灯光交互的其他属性：RGBA、镜面反射、光泽度、发射。材料也可用于使对象具有反射性。目前反射仅在平面和盒子的 Z+ 面上渲染。请注意，模型元素也可以具有用于设置颜色的本地 RGBA 参数。如果同时指定了材质和局部 RGBA，则局部定义具有优先权。

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#kinematic-tree)运动树

MuJoCo 模拟运动通常受到约束的刚体集合的动力学。系统状态用关节坐标表示，身体被明确地组织成运动树。除了顶级“世界”主体之外的每个主体都有一个唯一的父级。不允许有运动回路；如果需要循环关节，则应使用等式约束对其进行建模。因此，MuJoCo 模型的主干是由嵌套体定义形成的一棵或几棵运动树；一个孤立的浮体算作一棵树。下面列出的其他几个元素在一个主体内定义并属于该主体。这与后面列出的不能与单个主体相关联的独立元素形成对比。

身体

物体具有质量和惯性特性，但没有任何几何特性。而是将几何形状（或几何图形）附加到主体上。每个物体都有两个坐标系：用于定义它以及相对于它定位其他元素的坐标系，以及以物体质心为中心并与其惯性主轴对齐的惯性坐标系。因此，身体惯性矩阵在该坐标系中是对角线的。在每个时间步，MuJoCo 递归计算正向运动学，在全局笛卡尔坐标中产生所有身体位置和方向。这为所有后续计算提供了基础。

联合的

关节在实体内定义。它们在身体与其父对象之间创建运动自由度 (DOF)。在没有接头的情况下，主体被焊接到其母体上。这与使用过完备笛卡尔坐标的游戏引擎相反，其中关节移除自由度而不是添加自由度。有四种类型的关节：球、滑动、铰链和创建浮动体的“自由关节”。一个身体可以有多个关节。通过这种方式，可以自动创建复合关节，而无需定义虚拟实体。球关节和自由关节的方向分量表示为单位四元数，MuJoCo 中的所有计算都尊重四元数的性质。

自由度

自由度与关节密切相关，但不是一一对应的，因为球关节和自由关节有多个自由度。将关节​​视为指定位置信息，将自由度视为指定速度和力信息。更正式地说，关节位置是系统配置流形上的坐标，而关节速度是当前位置处该流形的切线空间上的坐标。DOF 具有与速度相关的特性，例如摩擦损失、阻尼、电枢惯性。作用在系统上的所有广义力都在自由度空间中表示。相比之下，关节具有与位置相关的属性，例如限制和弹簧刚度。自由度不是由用户直接指定的。相反，它们是由给定关节的编译器创建的。

乔姆

几何图形是刚性连接到主体的 3D 形状。多个几何体可以附加到同一个主体上。鉴于 MuJoCo 仅支持凸几何体与几何体碰撞，并且创建非凸对象的唯一方法是将它们表示为凸几何体的并集，因此这特别有用。除了碰撞检测和随后的接触力计算外，几何体还用于渲染，以及在省略后者时自动推断身体质量和惯性。MuJoCo 支持多种原始几何形状：平面、球体、胶囊、椭圆体、圆柱体、长方体。几何体也可以是网格或高度场；这是通过引用相应的资产来完成的。几何体具有许多影响模拟和可视化的材料属性。

地点

站点本质上是轻型几何体。它们代表身体框架内感兴趣的位置。站点不参与碰撞检测或惯性属性的自动计算，但它们可用于指定其他对象的空间属性，如传感器、肌腱路由和滑块曲柄端点。

相机

可以在一个模型中定义多个相机。总是有一个默认的相机，用户可以在交互式可视化器中用鼠标自由移动。然而，定义附加的相机通常很方便，这些相机要么固定到世界上，要么附着在其中一个物体上并随它移动。除了相机的位置和方向，用户还可以调整立体渲染的视野和瞳距，以及创建立体虚拟环境所需的斜投影。

光

灯光可以固定在世界物体上或附加到移动物体上。可视化器提供对 OpenGL（固定功能）中完整光照模型的访问，包括环境、漫反射和镜面反射组件、衰减和截止、位置和定向照明、雾。灯光，或者更确切地说是由它们照亮的物体，也可以投射阴影。但是，与材质反射类似，每个阴影投射灯都会添加一个渲染通道，因此应谨慎使用此功能。详细记录照明模型超出了本章的范围；请参阅[OpenGL 文档](http://www.glprogramming.com/red/chapter05.html)。请注意，除了用户在运动树中定义的灯光之外，还有一个随相机移动的默认大灯。它的属性通过 mjVisual 选项进行调整。

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#stand-alone-elements)独立元素

在这里，我们描述不属于单个主体的模型元素，因此在运动树之外进行描述。

参考姿势

参考姿势是存储在 中的关节位置向量`mjModel.qpos0`。当模型处于初始配置时，它对应于关节的数值。在我们之前的示例中，肘部是以 90° 角的弯曲配置创建的。但是 MuJoCo 不知道肘部是什么，因此默认情况下它将此关节配置视为数值为 0。我们可以覆盖默认行为并指定初始配置对应于 90°，使用[:ref](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id32)的 ref 属性[:`joint <joint>`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id32)。所有关节的参考值被组装成向量`mjModel.qpos0`。每当重置模拟时，关节配置 `mjData.qpos`都会设置为`mjModel.qpos0`. 在运行时，关节位置向量相对于参考姿势进行解释。特别是，关节应用的空间变换量为`mjData.qpos - mjModel.qpos0`。此转换是对存储在 的 body 元素中的父子平移和旋转偏移的补充`mjModel`。ref 属性仅适用于标量关节（滑动​​和铰链）。对于球关节，保存的四元数`mjModel.qpos0`始终为 (1,0,0,0)，对应于零旋转。对于自由关节，浮体的全局 3D 位置和四元数保存在`mjModel.qpos0`.

弹簧参考姿势

这是所有关节和肌腱弹簧达到其静止长度的姿势。当关节配置偏离弹簧参考姿势时会产生弹簧力，并且在偏差量上呈线性。弹簧参考姿势保存在`mjModel.qpos_spring`. 对于滑动和铰链关节，弹簧参考由属性 springref 指定。对于球关节和自由关节，弹簧参考对应于初始模型配置。

肌腱

肌腱是标量长度元素，可用于驱动、施加限制和等式约束，或创建弹簧阻尼器和摩擦损失。有两种类型的肌腱：固定的和空间的。固定肌腱是（标量）关节位置的线性组合。它们可用于模拟机械耦合。空间肌腱被定义为通过一系列指定位置（或通过点）或环绕指定几何体的最短路径。仅支持球体和圆柱体作为包裹几何体，并且出于包裹目的，圆柱体被视为具有无限长度。为了避免肌腱从包裹几何体的一侧突然跳跃到另一侧，用户还可以指定首选侧。如果在肌腱路径中有多个包裹几何体，它们必须被站点分开，以避免需要迭代求解器。也可以使用滑轮将空间肌腱分成多个分支。

执行器

MuJoCo 提供了一个灵活的执行器模型，具有可以独立指定的三个组件。它们共同决定了执行器的工作方式。通过以协调的方式指定这些组件，可以获得常见的执行器类型。这三个组成部分是传输、激活动力学和力生成。传输指定执行器如何连接到系统的其余部分；可用的类型有关节、肌腱和曲柄滑块。激活动力学可用于模拟气动或液压缸以及生物肌肉的内部激活状态；使用这种执行器使整个系统动态达到三阶。力生成机制决定了作为输入提供给执行器的标量控制信号如何映射为标量力，

传感器

MuJoCo 可以生成保存在全局数组中的模拟传感器数据`mjData.sensordata`。结果不用于任何内部计算；相反，提供它是因为用户可能需要它来进行自定义计算或数据分析。可用的传感器类型包括触摸传感器、惯性测量单元 (IMU)、力-扭矩传感器、关节和肌腱位置和速度传感器、致动器位置、速度和力传感器、运动捕捉标记位置和四元数以及磁力计。其中一些需要额外的计算，而另一些则从相应的字段中复制`mjData`. 还有一个用户传感器，允许用户代码在传感器数据阵列中插入任何其他感兴趣的数量。MuJoCo 还具有离屏渲染功能，可以直接模拟彩色和深度相机传感器。这不包含在标准传感器模型中，而是必须以编程方式完成，如代码示例[模拟.cc 中所示](https://github.com/deepmind/mujoco/blob/main/sample/simulate.cc)。

平等

除了运动树结构和其中定义的关节/自由度已经施加的约束之外，等式约束还可以施加额外的约束。它们可用于创建环形接头，或用于一般的机械耦合模型。强制执行这些约束的内力与所有其他约束力一起计算。可用的等式约束类型有： 在一个点连接两个物体（在运动树外创建一个球关节）；将两个身体焊接在一起；使两个表面相互滑动；固定关节或肌腱的位置；通过三次多项式耦合两个关节或两个肌腱的位置。

接触对

MuJoCo 中的联系人生成是一个复杂的过程。检查接触的几何对可以来自两个来源：自动邻近测试和其他统称为“动态”的过滤器，以及模型中提供的几何对的明确列表。后者是一种单独类型的模型元素。由于接触涉及两个几何体的组合，显式规范允许用户以动态机制无法完成的方式定义接触参数。它对于微调接触模型也很有用，特别是添加被激进过滤方案删除的接触对。

联系人排除

这与接触对相反：它指定应该从候选接触对的生成中排除的实体对（而不是几何体）。它对于禁用几何体之间的接触很有用，这些几何体会导致不希望的永久接触。请注意，MuJoCo 有其他机制来处理这种情况（特别是如果几何体属于同一主体或父主体和子主体，则它们不会发生碰撞），但有时这些自动化机制是不够的，需要显式排除。

自定义数字

在 MuJoCo 模拟中可以通过三种方式输入自定义数字。首先，可以在 XML 中定义全局数字字段。它们有一个名称和一个实数值数组。其次，可以使用特定于元素的自定义数组来扩展某些模型元素的定义。这是通过`nuser_XXX`在 XML 元素中 设置属性来完成的`size`。第三，有一个`mjData.userdata`未被任何 MuJoCo 计算使用的数组。用户可以在那里存储自定义计算的结果；回想一下，随时间变化的所有内容都应该存储 `mjData`在`mjModel`.

自定义文本

自定义文本字段可以保存在模型中。它们可用于自定义计算 - 指定关键字命令，或提供一些其他文本信息。但是不要将它们用于评论；在编译模型中保存注释没有任何好处。XML 有自己的注释机制（被 MuJoCo 的解析器和编译器忽略）更合适。

自定义元组

自定义元组是 MuJoCo 模型元素的列表，可能包括其他元组。它们不被模拟器使用，但可用于指定用户代码所需的元素组。例如，可以使用元组来定义用于自定义接触处理的实体对。

关键帧

关键帧是模拟状态变量的快照。它包含关节位置、关节速度、执行器激活（当存在时）和模拟时间的向量。该模型可以包含一个关键帧库。它们可用于将系统状态重置为感兴趣的点。请注意，关键帧并非用于在模型中存储轨迹数据；为此应使用外部文件。

## [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#clarifications)澄清

读者很可能有其他物理模拟器和相关约定的经验，以及与 MuJoCo 不一致的一般编程实践。这有可能引起混淆。本节的目标是先发制人地澄清最容易混淆的方面；它介于常见问题解答和选定主题的教程之间。我们将需要参考文档后面涵盖的材料，但尽管如此，下面的文本还是尽可能独立和介绍性的。

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#not-object-oriented)不是面向对象的

面向对象的编程是一种非常有用的抽象，它建立在更基本（并且更接近硬件）的数据结构与对它们进行操作的函数的概念之上。对象是与一个语义实体相对应的数据结构和函数的集合，因此它们之间比应用程序的其余部分具有更强的依赖性。我们在这里不使用它的原因是因为依赖结构使得自然实体是整个物理模拟器。我们有少量的数据结构和大量对它们进行操作的函数，而不是对象。

我们仍然使用一种类型的分组，但它不同于面向对象的方法。我们将模型 ( `mjModel`) 与数据 ( `mjData`)分开。这两个都是数据结构。该模型包含描述正在建模的物理系统的常数属性所需的一切，而数据包含时变状态和内部计算的可重用中间结果。所有顶级函数都需要指向`mjModel` 和`mjData`作为参数的指针。这样我们避免了污染工作空间和干扰多线程的全局变量，但我们这样做的方式与面向对象编程实现相同效果的方式不同。

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#softness-and-slip)柔软和滑动

正如我们将在[:doc:`computation`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id35)章节详细解释的那样，MuJoCo 基于接触物理和其他约束的数学模型。这个模型本质上是软的，从某种意义上说，对约束施加更大的压力总是会导致更大的加速度，因此可以唯一定义逆动力学。这是可取的，因为它产生了一个凸优化问题，并使依赖于逆动力学的分析成为可能，此外，我们在实践中需要建模的大多数接触都具有一定的软性。然而，一旦我们允许软约束，我们就有效地创建了一种新型动力学——即变形动力学——现在我们必须指定这些动力学的行为方式。这需要对接触和其他约束进行详细的参数化，包括属性 [:at:`solref`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id37)和[:at:`solimp`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id39)可以根据约束设置，稍后将进行描述。

这种软模型的一个经常令人困惑的方面是无法避免逐渐接触滑动。同样，摩擦关节会在重力作用下逐渐屈服。这并不是因为求解器无法在达到摩擦锥或摩擦损失极限的意义上防止滑移，而是因为它从一开始就没有尝试防止滑移。回想一下，针对给定约束的更大的力必须导致更大的加速度。如果要完全抑制滑移，则必须违反这一关键特性。因此，如果您在模拟中看到逐渐滑移，直观的解释可能是摩擦力不足，但在 MuJoCo 中很少出现这种情况。相反，需要调整`solref`和 `solimp`参数向量以减少这种影响。增加约束阻抗（前两个元素`solimp`) 以及全局`mjModel.opt.impratio`设置可能特别有效。这种调整通常需要较小的时间步长来保持模拟稳定，因为它们使非线性动力学更难以数值积分。牛顿求解器也减少了滑移，通常更准确。

对于需要完全抑制滑移的情况，可以`noslip`在主求解器之后运行第二个求解器。它通过忽略约束软度来更新摩擦尺寸中的接触力。然而，当使用此选项时，MuJoCo 不再解决它旨在解决的凸优化问题，并且模拟可能变得不那么稳健。因此使用具有椭圆摩擦锥和较大值的牛顿求解器 `impratio`是减少滑移的推荐方法。

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#types-names-ids)类型、名称、ID

如前所述，MuJoCo 支持大量模型元素。每个元素类型在`mjModel`列出其各种属性时都有一个相应的部分。例如关节极限数据在数组中

mjtNum* jnt_range; //关节限制 (njnt x 2)

每个数组的大小（`njnt`在这种情况下）也在`mjModel`. 首先包括第一个关节的限制，然后是第二个关节的限制等。这种排序反映了 MuJoCo 中的所有矩阵都具有行主格式的事实。

可用的元素类型在[mjmodel.h](https://github.com/deepmind/mujoco/blob/main/include/mjmodel.h#L243)中定义 ，在枚举类型[:ref:`mjtObj` 中](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id41)。这些枚举主要在内部使用。一个例外是MuJoCo API中的函数[:ref:`mj_name2id`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id43)和[:ref:`mj_id2name`](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#id45)，它们将元素名称映射到整数 id，反之亦然。这些函数将元素类型作为输入。

XML 中的命名模型元素是可选的。相同类型的两个元素（例如两个关节）不能具有相同的名称。仅当需要在模型的其他地方引用给定元素时才需要命名；XML 中的引用只能通过名称来完成。编译模型后，名称仍会存储在其中`mjModel`以方便用户使用，尽管它们对模拟没有进一步的影响。名称对于查找相应的整数 id 以及渲染很有用：例如，如果您启用关节标签，则会在每个关节旁边显示一个字符串（未定义名称的元素被标记为“关节 N”，其中 N 是 id） .

元素的整数 id 对索引 MuJoCo 数据数组至关重要。id 是基于 0 的，遵循 C 约定。假设我们已经有了`mjModel* m`. 要打印名为“elbow”的关节的范围，请执行以下操作：

int jntid = mj_name2id(m, mjOBJ_JOINT, "肘部" ); if ( jntid>= 0 ) printf ( " ( %f , %f ) \n " , m->jnt_range[ 2 *jntid], m->jnt_range[ 2 *jntid+ 1 ]);

如果未找到该名称，则该函数返回 -1，这就是为什么应始终检查 id>=0 的原因。

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#bodies-geoms-sites)实体、几何体、站点

实体、几何体和站点是 MuJoCo 元素，它们大致对应于物理世界中的刚体。那么为什么它们是分开的呢？出于语义和计算原因，这里解释了。

首先是相似之处。实体、几何体和站点都有附加到它们的空间框架（尽管实体也有第二个框架，该框架以身体质量中心为中心并与惯性主轴对齐）。这些框架的位置和方向是`mjData.qpos`通过正向运动学在每个时间步长计算的。正向运动学的结果可`mjData`用于身体的 xpos、xquat 和 xmat，geoms 的 geom_xpos 和 geom_xmat，站点的 site_xpos 和 site_xmat。

现在的差异。实体用于构建运动树，并且是其他元素（包括几何体和站点）的容器。实体具有空间框架、惯性属性，但没有与外观或碰撞几何体相关的属性。这是因为这些属性不会影响物理（当然接触除外，但这些是分开处理的）。如果您在机器人学教科书中看到过运动学树的图表，那么身体通常被绘制为无定形的形状 - 以表明它们的实际形状与物理学无关。

几何体（几何图元的缩写）用于指定外观和碰撞几何体。每个 geom 都属于一个主体，并严格地依附在该主体上。多个几何体可以附加到同一个主体上。鉴于 MuJoCo 的碰撞检测器假设所有几何体都是凸的（如果网格不是凸的，它在内部用它们的凸包替换网格），这特别有用。因此，如果您想对非凸形状进行建模，则必须将其分解为凸几何的并集，并将它们全部附加到同一主体上。Geoms 在 XML 模型中也可以有质量和惯性（或者更确切地说是用于计算质量和惯性的材料密度），但这仅用于在模型编译器中计算身体质量和惯性。在实际`mjModel`被模拟的几何体中没有惯性属性。

站点是轻量级的。它们具有相同的外观属性，但不能参与碰撞，也不能用于推断身体质量。另一方面，站点可以做 geoms 不能做的事情：他们可以指定触摸传感器的体积、IMU 传感器的连接、空间肌腱的路由、滑块曲柄执行器的端点。这些都是空间量，但它们并不对应于应该具有质量或碰撞其他实体的实体——这就是创建站点元素的原因。站点也可用于指定用户感兴趣的点（或帧）。

以下示例说明了可以将多个站点和 geom 附加到同一主体的观点：在这种情况下，两个站点和两个 geom 可以附加到一个主体。

<穆乔科> <世界体> <体 POS = “ 0 0 0 ” > < geom  type = " sphere "  size = " .1 "  rgba = " .9 .9 .1 1 " /> < geom  type = " capsule "  pos = " 0 0 .1 "  size = " .05 .1 "  rgba = " .9 .9 .1 1 " /> <站点 类型= “框”  pos = “ 0-.1.3 ” 大小= “. 02.02.02 ”  rgba = “ .9.1.91 ” /> <站点 类型= “椭圆体”  pos = “ 0.1.3 ” 大小= “. 02.03.04 ”  rgba = “ .9.1.91 ” /> </正文> </世界体> </穆乔科>

[![图像/概述/bodygeomsite.png](https://github.com/tigerneil/mujoco-zh/raw/main/doc/images/overview/bodygeomsite.png)](https://github.com/tigerneil/mujoco-zh/blob/main/doc/images/overview/bodygeomsite.png)

该模型由 OpenGL 可视化器呈现为：

注意红框。这是身体惯性属性的等效惯性盒渲染，由 MuJoCo 内部生成。该框位于 geoms 上方，但未位于站点上方。这是因为只有几何体用于（自动）推断物体的惯性属性。如果我们碰巧知道后者，我们当然可以直接指定它们。但是，使用均匀密度的假设（可以在 XML 中指定几何体密度；默认为水的密度），让模型编译器从附加到它的几何体中推断这些物体属性通常更方便。

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#joint-coordinates)关节坐标

MuJoCo 和游戏引擎（例如 ODE、Bullet、Havoc、PhysX）之间的主要区别之一是 MuJoCo 在广义坐标或联合坐标中运行，而游戏引擎在笛卡尔坐标中运行，尽管 Bullet 现在支持广义坐标。这两种方法之间的差异可以总结如下：

关节坐标：

-   最适合精细的运动结构，如机器人；
-   关节在默认情况下焊接在一起的主体之间增加了自由度；
-   联合约束隐含在表示中，不能违反；
-   模拟体的位置和方向是通过正向运动学从广义坐标中获得的，不能直接操纵（根体除外）。

笛卡尔坐标：

-   最适合许多相互反弹的物体，如分子动力学和盒子堆叠；
-   关节移除默认情况下自由浮动的物体之间的自由度；
-   联合约束以数字方式强制执行并且可以被违反；
-   模拟体的位置和方向被明确表示并且可以直接操纵，尽管这可能会引入进一步的关节约束违规。

当使用作为模型一部分的自由浮动体时，关节坐标可能会特别混乱，该模型还包含运动树。这在下面澄清。

### [](https://github.com/tigerneil/mujoco-zh/blob/main/doc/overview.rst#floating-objects)漂浮物

在关节坐标中工作时，您不能简单地将任意物体的位置和方向设置为您想要的任何值。要实现这种效果，您必须实现某种形式的反向运动学，它计算一组（不一定是唯一的）关节坐标，正向运动学将身体放置在您想要的位置。

浮动体的情况有所不同，即通过自由关节连接到世界的物体。此类物体的位置和方向以及线速度和角速度在`mjData.qpos`和中明确表示， `mjData.qvel`因此可以直接操纵。一般的做法是在qpos和qvel中找到body数据所在的地址。当然qpos和qvel代表的是关节而不是身体，所以需要对应的关节地址。假设主体在 XML 中被命名为“myfloatingbody”。可以通过以下方式获得必要的地址：

int bodyid = mj_name2id(m, mjOBJ_BODY, " myfloatingbody " ); int qposadr = - 1 , qveladr = - 1 ;
//确保我们有一个浮动体：它有一个自由关节
if ( bodyid>= 0 && m->body_jntnum[bodyid]== 1 && m->jnt_type[m->body_jntadr[bodyid]]==mjJNT_FREE ) {
      //从联合规范中提取地址 qposadr = m-> jnt_qposadr [m-> body_jntadr [bodyid]]; qveladr = m-> jnt_dofadr [m-> body_jntadr [bodyid]]; }

现在，如果一切顺利（即“myfloatingbody”确实是一个浮体），qposadr 和 qveladr 是 qpos 和 qvel 中浮体/关节数据所在的地址。位置数据为 7 个数字（3D 位置后跟单位四元数），而速度数据为 6 个数字（3D 线速度后跟 3D 角速度）。现在可以将这些数字设置为所需的身体姿势和速度。
